\section{Capitulo 4: Fundamentos teoricos de la computación distriuida}
\subsection{Historias Causales}
Las \textbf{Historias causales} permiten detectar si existe \textcolor{red}{\textbf{Concurrencia}} o \textcolor{red}{\textbf{Causalidad}} entre dos eventos

\begin{center}
    $\subset$ : \textbf{Contenido} $\Rightarrow$ : $A=\left\{1,2\right\} $ y $B=\left\{1,2,3\right\}$ podemos decir que A $\subset$ B
\end{center}

de lo antes definido tenemos lo siguiente:

\begin{itemize}
    \item \[ \forall e, e' \in E, e \neq e' : [e' \rightarrow e] \Leftrightarrow H(e') \subset H(e) \]
    Esto se puede traducir como: \textcolor{red}{Si $e'$ ocurre antes que $e$, entonces $H(e')$ es un subconjunto de $H(e)$}.

    \item \[ \forall e, e' \in E, e \neq e' : [e' \parallel e] \Leftrightarrow [H(e') \nsubseteq H(e)] \land [H(e) \nsubseteq H(e')] \]
    Esto se lee como: \textcolor{red}{Si $e'$ es concurrente con $e$, entonces $H(e')$ no es un subconjunto de $H(e)$ y $H(e)$ no es subconjunto de $H(e')$}.
\end{itemize}

\subsection{Relojes vectoriales}
Para los relojes vectoriales definiremos la siguiente estructura para el un proceso $P_i$, para n procesos
\[
   \left[ \mathit{Vc}[1], \mathit{Vc}[2], \dots, \mathit{Vc}[i], \dots, \mathit{Vc}[n] \right]
\]

Donde cada indice esta asociado a un proceso $P_i$. De los relojes vectoriales sabemos que $\forall e \in E$: Vc(e) representa H(e).

Continuando, los procesos irán aumentando de la sigueinte forma:

Para \textcolor{red}{\textbf{eventos locales} del proceso $P_i$}:
\begin{enumerate}[label=\textbf{Paso \arabic*:}]
    \item :\\
    Se suma 1 al Vc($e_i$)[i], vale decir que le sumamos 1 a la marca del proceso i
    \item :\\
    Asignarle el valor anterior al resto de los otros procesos, al nuevo evento

    \[
\textcolor{green!50!black}{
  \left[ 
    \mathit{Vc}[1], \mathit{Vc}[2], \dots, 
  }
\textcolor{black}{
    \mathit{Vc}[i]
}
\textcolor{green!50!black}{
    , \dots, \mathit{Vc}[n]
  \right]
}
\]

donde los indices en verde, se mantendran iguales para el evento local.\\
\end{enumerate}

Resultando Finalmente en el siguiente vector para $P_i$

\[
\textcolor{green!50!black}{
  \left[ 
    \mathit{Vc}[1], \mathit{Vc}[2], \dots, 
  }
\textcolor{black}{
    \mathit{Vc}[i] + 1
}
\textcolor{green!50!black}{
    , \dots, \mathit{Vc}[n]
  \right]
}
\]

Para mensajes entre procesos, solo se modifica la marca del proceso que esta mandando el mensaje, por ejemplo, si $P_i$ manda un mensaje a $P_j$, se modifica la marca del vector $P_j$ asociada a $P_i$.

\subsubsection{Propiedades de los rejoles vectoriales}

Lo siguiente que denotameros es \textcolor{red}{\textbf{condición fuerte de un reloj en sistemas distribuidos}} se refiere a la capacidad de determinar de forma bidireccional si un evento precede causalmente a otro, permitiendo un ordenamiento total o casi total de los eventos en el sistema.
\begin{enumerate}
  \item Relación de igualdad:
  \[
  V=V' \equiv  [\forall k: V[k]=V'[K]]
  \]
  \item Relación de orden: 
  \[
  V<V' \equiv [V \neq V'] \land [\forall k: V[k] \leq V'[k]]
  \]
  \item Condición fuerte:
  \[
    e \rightarrow e' \equiv VC(e) < VC(e')
  \]
  \[
      e || e' \equiv \lnot [VC(e)<VC(e')]\land \lnot[VC(e')<VC(e)]
  \]
\end{enumerate}

El  numero de eventos precedentes es equivalente a la suma del vector completo, menos el evento mismo.

La propiedad de detección de apertura nos permite a un proceso $P_j$ detectar que existe un evento e' que ocurre en otro $P_i$ despues de un evento $e_i$ ya conocido por $P_j$. Notese además que los relojes vectoriales tienen la capacidad de \textbf{detectar causalidad, concurrencia, coordinacion centralizada y es tolerante a fallos}. Sin embargo tiene limitaciones, como, \textbf{overhead, complejidad (más complejo que lamport), si bien dijimos que tolera fallas, es deficiente ante fallas bizantinas y sistemas altamente dinamicos (con una entrada y salida de procesos, dado que se tiene que redimencionar el vector)}



