\section{Capítulo 6: Confiabilidad y tolerancia a fallos}

\textbf{Confiabilidad:} La confianza que se puede tener en un sistema, aun en presencia de errores, fallos y condiciones inesperadas.

Atributos claves

\begin{enumerate}
    \item \textcolor{red}{\textbf{Fiabilidad:}} Continuidad correcta del servicio sin fallas o interrupciones.
    \item \textcolor{red}{\textbf{Disponibilidad:}} La disposición de un servicio a ser usado en cualquier tiempo \textbf{T} .
    \item \textcolor{red}{\textbf{Mantenibilidad:}} Facilidad de mantener, actualizar y reparar un sistema que puede fallar.
    \item \textcolor{red}{\textbf{Protección:}} Ausencia de consecuencias catastróficas sobre el medio ambiente.
    \item \textcolor{red}{\textbf{Seguridad}} Prevenir el acceso o manipulación no autorizaco (alineado con la \textcolor{red}{\textbf{CIA: Confidencialidad, Integridad y Disponibilidad}}).
\end{enumerate}

Los atributos antes mencionados son cuantificables y medibles para el analisis de la \textbf{tolerancia a fallos}.

\subsection{Modelo Causal de averias}
Para este contexto definiremos al sistema como un conjunto de componentes tanto de hardware como de software, preparados para colaborar coordinadamente para ofrecer un servicio, según pautas establecidas para un correcto funcionamiento.


Pero, que causa un mal funcionamiento de un sistema. Partiremos definiendo 3 diferencias claves para el analisis.

\begin{itemize}
    \item \textcolor{red}{\textbf{Fallo(\textit{fault}):}} Defecto o funcionamiento anormal de un componente, el cual tiene el potencial de causar un \textcolor{red}{\textbf{error}}, en caso de no ser tratado \textcolor{red}{\textbf{puede llevar a una averia}}. Se clasifican segun persistencia (\textcolor{red}{\textbf{transistente, intermitente o permanente}}) y según causa \textcolor{red}{\textbf{error de manofactura, diseño u operacional}} 
    \item \textcolor{red}{\textbf{Error:}} Discrepancia entre el comportamiento esperado y el exhibido
    \item \textcolor{red}{\textbf{Averia(\textit{failture}):}} Ocurre un malfuncionamiento que conduce a que ya no se pueda proveer el servicio especificado. Son causadas por errores que se propagar a lo largo del sistema, llegando a ser observables por el usuario.
    \subitem \textbf{Un error o fallo no necesariamente conduce a una averia, si este es tratado y manejado adecuadamente}
\end{itemize}

Las \textbf{\textit{fallas}} o \textbf{\textit{averias}} se clasifican según su comportamiento en el sistema

\begin{itemize}
    \item Fallas de \textcolor{purple}{\textbf{caida (\textit{crash}):}} Componente se detiene y no se recupera por si mismo
    \subitem \textcolor{red}{\textbf{Proceso:}} Proceso fallado se detiene, puede perder su estado. Es la mas benigna es detenerse manteniendo su estado, para posteriormente recuperarlo. Para la detenccion fiable por parte de otros procesos se requieren \textcolor{red}{\textit{timers}}
    \subitem \textcolor{red}{\textbf{Comunicación:}} Falla del sistema de comunicación con pérdida continua de mensajes (e.g falla permanenete o partición de red)

    \item Fallas de \textcolor{purple}{\textbf{omisión:}} El sistema no responde transitoriamente
    \subitem \textcolor{red}{\textbf{Proceso:}} Proceso no responde, sin perder estado \textcolor{red}{(e.g., se pierde una solicitud de servicio)}.
    \subitem \textcolor{red}{\textbf{Comunicación:}} Se pierden algunos mensajes. Falla mas benigna es que mensajes no se corrompen (integridad) y no se puede falsear su
    remitente (autenticidad). Recuperación es por retransmisión de mensajes perdidos.

    \item Fallas \textcolor{purple}{\textbf{temporales (\textit{timing}):}} El sistema no responde dentro de los limites de tiempo.
    \subitem Pueden corresponder a un mal desempeño por sobrecarga. 
    \subitem Pueden ocurrir por fallas de relojes.

    \item Fallas \textcolor{purple}{\textbf{arbitrarias (\textit{bizantinas}):}} El sistema se comporta inconsistente o maliciosamente.
    \subitem Los procesos fallas siguen funcionando pero no garantizan la integridad de los mensajes \textcolor{red}{\textbf{(peor caso)}}
    \subitem A veces se produce por corrupción interna del sistema, causan respuestas erroneas pero no maliciosas
    \subitem Son fallas dificiles de detectar y tolerar
\end{itemize}


Una vez definidas el tipo de fallas, estableceremos los modelos para los tipos de fallas, en base a una jerarquia (esta ordenada de adentro hacia afuera, vale decir, de la más "debil" a la más dañina).

\begin{itemize}
    \item \textcolor{red}{\textbf{Fail-stop:}} Un proceso fallado se detiene, conservando su estado, y todos los demas saben inmediatamente que ha fallado. Los procesos se comportan correctamente o se detienen.
    \item \textcolor{red}{\textbf{Crash:}} Modelo realista de incertidumbre para sistemas asincronicos. Un proceso fallado se detiene, conserva su estado, pero los demás no lo saben ni estan seguros si se cayo o esta lento o tiene problemas de comunicación. Puede recuperarse y reintegrarse al sistema
    \item \textcolor{red}{\textbf{Omisión:}} Solo un proceso puede omitir enviar o recibir mensajes. Se puede abordar con el uso de timers, reintento y asentimientos.
    \item \textcolor{red}{\textbf{Temporal (\textit{timing}):}} El sistema puede violar restricciones temporales, tal como respuestas fuera de tiempo. Dificil de discriminar entre fallas de crash y omisión
    \item \textcolor{red}{\textbf{Bizantino:}} Un proceso puede enviar mensajes contradictorios, mentir sobre su estado interno o colaborar maliciosamente con otros. Corresponde a un modelo más general
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.48\linewidth]{img/Modelo_Causal_de_averias.png}
    \caption{Modelo Causal de averias}\label{fig:1761579857293}
\end{figure}


Para manejar lo anterior, se propone los siguientes enfoques para mejorar la confiabilidad del sistema.

\begin{itemize}
    \item \textcolor{red}{\textbf{Prevención de fallos:}} Prevenir que ocurran o se introduzcan fallos en el sistema
    \item \textcolor{red}{\textbf{Remoción de fallos}} durante el desarrollo o durante el uso \textbf{(mantención y reparación)}
    \item \textcolor{red}{\textbf{Pronóstico de fallos:}} Predecir fallos probables, para que puedan ser anticipadamente eliminadas o contener sus efectos \textbf{(e.g. alertas y detección de degradación/anomalías)}
    \item \textcolor{red}{\textbf{Pronóstico de fallos:}} Capacidad de un sistema para seguir funcionando normalmente, aun cuando seproduzcan uno o más fallos de sus componentes.
    \subitem Se debe disponer de algún tipo de redundancia para enmascarar fallos.
    \subitem Capacidad de reparar un fallo sin interrumpir el servicio, para asegurar continuidad operacional del servicio.
\end{itemize}

\subsection{Tolerancia a fallos}
La tolerancia a fallos es \textcolor{Sepia}{la capacidad de enmascarar la existencia de fallos} en un sistema, usando redundacia. Esto busca \textcolor{ForestGreen}{evitar una averia o falla del sistema}. Si bien un sistema puede ser tolerante a fallos, estos deberian ser de sus propios componentes, y no con fallas que comprometen todo el sistema. Queremos que el sistema, tenga un comportamiento consistente a lo especificado.
\vspace{1mm}

El \textcolor{Sepia}{manejo de fallos en un sistema es un proceso de cuatro fases}: primero, la \textbf{Detección de error}, donde los fallos se deducen por errores en el estado del sistema; segundo, la \textbf{Aislación y evaluación del daño}, que busca contener la expansión del error; tercero, la \textbf{Recuperación del error}, que corrige el problema y devuelve el sistema a un estado consistente (e.g., \textit{rollback}); y finalmente, el \textbf{Tratamiento del fallo y servicio contínuo}, que, ante fallos permanentes, reconfigura el sistema para dejar de usar el componente dañado y reemplazarlo.

La \textcolor{red}{\textbf{redundancia}} se define en base a las partes de un sistema que no son necesarias para su correcto funcionamiento, si no se requiere tolerar fallos. Existen 3 tipos de tolerancias
\begin{enumerate}
    \item \textbf{Espacial:} Se agregan componentes de redundantes de hardware o software.
    \item \textbf{Temporal:} Ejecutar y repetir varias veces una acción o secuencia de instrucciones. Un ejemplo es la retransmisión de mensajes, rollback de una acción y repetir su ejecición.
    \item \textbf{De información:} Se agrega información redundante para tolerar fallos.
\end{enumerate} 

\subsection{Enfoques de recuperación de errores}
Dos enfoques.

\textcolor{purple}{\textbf{Recuperación regresiva(\textit{backward recovery}):}} El sistema retrocede a un estado correcto anterior y se repite la ejecución, se introduce el concepto de checkpoints en la ejecución, % los cuales son puntos donde se guarda el estado del sistema en una memoria estable
(no se ve afectada por alguna averia). En caso de detectar errores, el sistema hace un rollback.

\textcolor{purple}{\textbf{Recuperación progresiva(\textit{forward recovery}):}} \textcolor{Sepia}{El sistema sigue avanzando, corrigiendo un posible estado erróneo}. Al detectarse errores, se sigue la ejecución mientras que a la par se realizan acciones correctivas. No es viable para todos los sistemas

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{img/Comparacion_enfoques.png}
    \caption{Comparativa de enfoques de recuperación}\label{fig:1761609494042}
\end{figure}

Esquemas para tolerancia a fallos
\begin{itemize}
    \item Transacciones o acciones atómicas
    \item Checkpoint y rollback
    \item Replicación de procesos
    \item Máquina de estado replicada o determinista: Basada en multicast atómico con orden total. Ordenamiento basado en conceso (Paxos,Raft)
\end{itemize}

\subsection{Máquina de estado determinista y replicada}
Grupo de replicación, \textcolor{Fuchsia}{donde cada proceso no fallado ejecuta los mismos comandos en el mismo orden}. Se caracteriza por el determinismo de estado. %donde todas las replicas correctas mantienen el mismo estado
 Se necesita consenso (dinámico) de los miembros del grupo, este consenso es sobre \textcolor{red}{\textbf{cúales comandos ejecutar y en que orden}}. Si se trabaja en un modelo \textbf{sin fallas}, \textcolor{ForestGreen}{se pueden usar relojes de lamport para ordenamiento global y total} de los mensajes del grupo o un secuenciador central. Para el caso del \textcolor{Sepia}{modelo con fallas}, se requieren de algoritmos de consesso tolerantes a fallos. 

Vamos a considerar lo siguiente, un contador $k$, el cuál es iniciado con un valor de 1, tenemos dos máquinas que ejecutarán las mismas instrucciones, pero en diferente orden:

\begin{tabular}{l|l}
\textcolor{red}{\textbf{Máquina A:}} & \textcolor{red}{\textbf{Máquina B:}} \\
$k \cdot 2$ & $k + 1$ \\
$k + 1$ & $k \cdot 2$ \\    
\end{tabular}       

Esto resulta en que el contador de la máquina A, es \textcolor{red}{$k=3$} y para la máquina B es \textcolor{red}{$k=4$}. Buscamos mantener un orden y los mismos comandos para ambas máquinas.

\subsection{Modelos cuantitativos de confiabilidad}
%Pagina 21
Se define la \textbf{fiabilidad R(t)} \textcolor{Sepia}{como la probabilidad de que un sistema no falle hasta el tiempo $t$}. Definimos \textbf{MTTF (Mean Time To Failure)} \textcolor{red}{como el tiempo de vida esperado sin un fallo del sistema}:

\[
  \textstyle  MTTF= \int_{0}^{\infty}R(t)dt
\]

Caso especial: donde $R(t)$ \textcolor{ForestGreen}{sigue una distribución exponencial} tenemos que $R(t)=\exp^{-\lambda t}$ y $MTTF= \frac{1}{\lambda}$

\subsubsection{Fiabilidad en serie}
{Sepia}{Es aquel en donde si un componente falla el sistema completo falla}. Donde $R_i(t)$ es la fiabilidad del componente i, y $\lambda_i$ es la tasa media de fallas. La fiabilidad del sistema es:

\[
  \textstyle  R_{serie}=\prod_{i=1}^{n} R_i(t)
\]
Caso especial, donde $R(t)$ \textcolor{Sepia}{sigue una distribución exponencia}l tenemos que $R(t)=\exp^{-\lambda t}$ y $MTTF_{serie}= \frac{1}{\lambda}$ con $\lambda= \sum_{i=1}^{n}\lambda_i $ 

\subsubsection{Fiabilidad en paralelo}
Es aquel donde \textcolor{Sepia}{si fallan \textbf{TODOS} los componentes, el sistema falla}.

\[
  \textstyle  R_{paralelo}= 1 - \prod_{i=1}^{n} (1-R_i(t))
\]

Caso especial, donde $R(t)$ sigue una distribución exponencial tenemos que $R(t)=\exp^{-\lambda t}$ y $MTTF_{paralelo}= \frac{1}{\lambda}*\frac{ln(n)}{\lambda}$ con $\lambda= \sum_{i=1}^{n}\lambda_i $

\subsubsection{Caso de fiabilidad en discos raid-4 y espejo}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.2\linewidth]{img/Espejo.png}
    \caption{Ejemplo disco espejo}\label{fig:1761834250462}
\end{figure}
Para este caso el $MTTF\approx\frac{1}{2}*\frac{MTTF^2}{MTTR}$


\begin{figure}[H]
    \centering
    \includegraphics[width=0.2\linewidth]{img/Raid-4.png}
    \caption{Ejemplo para discos fragmentados RAID-4}\label{fig:1761834325234}
\end{figure}

Para este caso el $MTTF\approx\frac{1}{n(n-1)}*\frac{MTTF^2}{MTTR}$. %El funcionamiento de este ultimo considera que se almacenan grupos de K bloques de datos y el uno de módulo dos (XOR) para el calculo de paridad. De lo anterior, se define lo siguiente para el calculo del bloque de datos $D_i$, y $P$ como la paridad del sistema.

% \[
%     \textstyle  D_i = D_1 \oplus D_2 \oplus \dots \oplus D_{i-1} \oplus D_{i+1} \oplus \dots \oplus D_k \oplus P
% \]

\subsection{Disponibilidad}
Disponibilidad instantánea como $A(T)$ como \textcolor{Sepia}{la probabilidad de que un sistema esté funcionando correctamente en un tiempo $T$}. Disponibilidad límite, se define como un valor $\alpha$, como la disponibilidad promedio en un invervalo $[0,\tau)$:

\[
   \textstyle  \alpha= \lim_{\tau \rightarrow \infty} \frac{1}{\tau}\int_{0}^{\tau}A(t)dt
\]

% Aca se comienza a hablar sobre el concepto de reparacion, de la cual definimos el siguiente "flujo" (Notar que ahora un componente tiene 2 estados, reparandose y funcionando). de la cual se extrae lo siguiente:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{img/MTTF.png}
    \caption{Flujo de vida de un componente}\label{fig:1761836148913}
\end{figure}
El MTTF corresponde al "\textcolor{ForestGreen}{Mean Time To Failure}", MTBF como "\textcolor{Sepia}{Mean Time Between Failure}" y MTTR como "\textcolor{red}{Mean Time To Repair}", tenemos que $MTBF= MTTF + MTTR$. Entonces la disponibilidad límite $\alpha$ como:

\[
    \textstyle  \alpha = \frac{MTTF}{MTTF+MTTR}
\]

\subsubsection{Caso de replicación de servidores}
Suponiendo un sistema de $n$ réplicas similares, donde la disponibilidad por servidor es de $a_0$, \textcolor{Sepia}{trabajando con un modelo en paralelo}, la solución de disponibilidad es $a_n=1-(1-a_0)^n$

\subsection{Acuerdo y consenso distribuido}
El consenso busca garantizar la consistencia y confiabilidad frente a fallas (de nodos, red o bizantinas) y asincronía. El \textcolor{blue}{objetivo es alcanzar una decisión común} satisfaciendo propiedades de \textcolor{blue}{\textbf{\textit{safety}}} (Acuerdo, Integridad, Validez) y \textcolor{purple}{\textbf{\textit{liveness}}} (Término).

En el problema del acuerdo, \textcolor{Sepia}{se busca decidir sobre un único valor o curso de acción tal que se satisfaca el }acuerdo (el valor decidido debe ser igual para todos), \textcolor{blue}{\textbf{integridad}} (no se puede cambiar la decisión de un participante), \textcolor{blue}{\textbf{validez}}(el valor elegido debio ser propuesto por alguno de los participales) y \textcolor{purple}{\textbf{término}} (se decide en tiempo finito). Notar que las tres primeras condiciones hacen referencia a \textcolor{blue}{\textbf{\textit{safety}}} y la última a \textcolor{purple}{\textbf{\textit{liveness}}}.
 
\textbf{Acuerdo}: \textcolor{red}{Existe un proceso designado (transmisor) que tiene y propone un valor inicial}, para alcanzar acuerdo con los demás procesos sobre este valor, según las siguientes condiciones:
\begin{itemize}
    \item \textbf{Acuerdo:} Un proceso \textit{transmisor} propone un valor. Todos los procesos correctos deben acordar el mismo valor (si el transmisor es correcto, se acuerda su valor inicial).
    \item \textbf{Consenso:} Cada proceso tiene un valor inicial. Todos los procesos correctos acuerdan un único valor común (si todos tenían el mismo valor inicial, ese debe ser el elegido).
    \item \textbf{Consistencia Interactiva:} Todos tienen un valor inicial. Se acuerda un vector de valores $A$, donde $A[i]$ corresponde al valor inicial del proceso $P_i$ (si este no ha fallado).
\end{itemize}

Para garantizar solución, se requiere una relación de fallas $f<n$ y comunicación fiable. \textcolor{red}{En sistemas puramente asincrónicos es imposible alcanzar una solución determinista}, dado que no se puede distinguir entre una demora y una falla.
\subsubsection{Algoritmo de acuerdo bizantino con mensajes ordinarios (no tienen ningún hash criptografico)}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{img/ordinario.png}
    \caption{Ejemplo de OM con n=4 y f=1}
    \label{fig:17161838884075}
\end{figure}

En este algoritmo, sólo \textcolor{Sepia}{se trabaja con un modelo de fallas bizantinas} y no de comunicación, donde se debe cumplir que $3f+1\leq n$ . Para el numero m de rondas, se cumple que existe a lo mas $m= f+1$ rondas.

\subsection{Comunicación grupal tolerante a fallos}
El principal enfoque es: una vez tengamos el mecanismo \text{}{Fuchsia}{necesitamos las herramientas} (replicación de maquina de estado, \textit{primary-backup}, sistemas basados en quorums) \textcolor{Fuchsia}{para la replicación de los datos}.

Dos tipos de multicast

\textbf{Simple}: \textcolor{blue}{No está determinado el número de receptores efectivos}, cuando existen emisores de uno o varios no está determinado el orden de llegada a los receptores, es útil para aplicaciones no críticas. \textcolor{red}{No tiene condiciones de consistencia}, es más eficiente o liviano

\textbf{Fiable}: \textcolor{Sepia}{Garantiza la entrega a procesos no fallados estando en presencia de fallos de comunicación}. Se retransmiten mensajes automáticamente, eliminando mensajes repetidos o corruptos.

\subsubsection{Semántica de entrega de mensajes}
\textbf{Fiabilidad de entrega}:
\begin{itemize}
    \item \textbf{Mejor esfuerzo} (Best-effort): \textcolor{blue}{Sin garantía sobre cuántos miembros reciben un mensaje}.
    \item \textbf{Fiabilidad-$k$}: \textcolor{ForestGreen}{Garantía de que al menos $k$ miembros reciben el mensaje}.
    \item \textbf{Atómico}: \textcolor{red}{Garantía de que todos los miembros lo reciben, o ninguno de ellos lo recibe}.
\end{itemize}
\textbf{Orden de entrega:}
\begin{itemize}
    \item \textbf{No ordenado}: \textcolor{blue}{Ninguna garantía de orden de entrega en el receptor}.
    
    \item \textbf{Orden FIFO}: Mensajes de un mismo emisor \textcolor{Sepia}{se entregan según orden de envío}.
      
    \begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{img/multi_fifo.png}
    \caption{Multicast: orden FIFO}\label{fig:1761678535409}
    \end{figure}

    \item \textbf{Orden causal}: Se respeta en la entrega \textcolor{red}{el orden causal de eventos de envío}.
    
    \begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{img/multi_causal.png}
    \caption{Multicast: orden causal}\label{fig:1761678585653}
\end{figure}


    \item \textbf{Orden total}: Único orden de entrega de los mensajes en los receptores. Podría requerir también cumplir orden causal.
    
    \begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{img/multi_total.png}
    \caption{Multicast: orden total}\label{fig:1761678629682}
\end{figure}
\end{itemize}
    
\textcolor{red}{\textbf{Obs.1}}: Es necesario utilizar multicast con entrega con orden total y causal pasa máquinas de estado replicadas deterministas para asegurar la entrega de comandos en el mismo orden.

En los grupos muchas veces existen miembros distinguidos (con un rol asociado), los nodos deben tomar el rol del nodo afectado una vez detectada la falla. Si en algún punto un nuevo nodo se integra al grupo, se debe sincronizar con los demás nodos.

\subsubsection{Modelo de sincronía virtual (modelo \textit{Fail-stop})}

La sincronía virtual es un modelo de comunicación \textcolor{ForestGreen}{que asegura consistencia de entrega de mensajes estando también en presencia de fallos}. Es fácil de implementar una máquina de estado replicada y determinista y replicada  en un modelo \textit{Fail-stop} multicast fiable y cambios de membresía. El modelo \textcolor{red}{no soporta fallas bizantinas ni particiones de red}.

El sistema es \textcolor{blue}{parcialmente asincrónico} dado que requiere de un \textit{timer} para detectar la falla de procesos.

\textbf{ABCAST:} \textcolor{Fuchsia}{Asegura orden total, tiene la semántica de entrega más fuerte}. Para que un grupo reciba un mensaje en el mismo orden se necesita un protocolo de dos fases. El proceso que manda un mensaje actúa como "coordinador", va a actuar en el grupo para determinar el orden en que deben de llegar los mensajes desde este coordinador, utiliza relojes de lamport y el id del proceso %, como un par ordenado de la forma $\left[LC, \textit{pid}\right]$, se maneja una cola para garantizar la condición de entrega ordenada.

En su primera fase $P_i$ envía un mensaje usando multicast fiable, una vez enviado el resto de los procesos del grupo (no fallados) \textcolor{red}{marca tentativamente los mensajes recibidos en base a su marca de lamport} $\left[LC_j, id_j\right]$, finalmente para cada mensaje recibido por el proceso $P_i$, los asigna como \textbf{No comprometido}, \textcolor{red}{(en la imagen, los mensajes con la N)}.

\textbf{Primera fase}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{img/Primer_paso.png}
    \caption{Primer paso ABCAST}\label{fig:1761653095435}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{img/Segundo_paso.png}
    \caption{Segundo paso ABCAST}\label{fig:1761653127112}
\end{figure}


En la segunda fase, una vez $P_i$ recibe la marca tentativa de sus miembros del grupo, marca la máxima marca tentativa como $t_m$, (en caso de que dos procesos tengan el mismo valor para el relojes, se desempata con el id). Finalmente, una vez definido el valor para el mensaje, Se le notifica a todos los procesos del grupo de la marca ganadora y se pasa al valor de comprometido a \textcolor{blue}{\textbf{TRUE}}.

\textbf{Segunda fase}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{img/Tercer_paso.png}
    \caption{Tercer paso ABCAST}\label{fig:1761653161267}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{img/Cuarto_paso.png}
    \caption{Cuarto paso ABCAST}\label{fig:1761653182730}
\end{figure}

Para establecer un número de mensajes por solicitud. Si hay N procesos, hay N envios, Como hay N procesos, hay N respuestas, y finalmente Se tiene que comunicar para los N procesos N actualizaciones de marca para un mensaje, resultando finalmente en que la \textcolor{red}{complejidad} es $3N$


\textbf{CBCAST:} \textcolor{red}{Asegura orden causal, hace uso de relojes vectoriales}, antes había un solo monitor, y cada miembro hace entrega causal. Las reglas son las siguientes. Para cada mensaje m, a ser enviado por $P_i$, se incrementa $VC_i[i]$, Cuando $P_j$,  recibe un mensaje m desde $P_i$, con la marca asociada al mensaje, entonces $P_j$ retarda la entrega de m hasta que se cumpla la condición \textcolor{red}{\textbf{FIFO}} y la condición \textcolor{red}{\textbf{CAUSAL}} (estas se definieron en el capitulo 4, y están en este apunte).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{img/CBCAST.png}
    \caption{Ejemplo visual de CBCAST}\label{fig:1761675486364}
\end{figure}

\textbf{Api de gestión de grupos:} Para asegurar atomicidad nos provee una interfaz para gestionar grupos, servicios como: crear grupo, unirse a un grupo, salir de un grupo (por detección termino o fallas), una lista de quienes reciben el mensaje (Vista) y notificar un cambio de en la lista del grupo.

Definimos un grupo atómico, un grupo donde todos los miembros tienen la misma vista. Cuando existen cambios en la vista (alguien se sale o une al grupo), este proceso necesariamente debe ser atómico.

\textbf{Básicos}:
\begin{itemize}
    \item $\mathit{GID} \leftarrow \text{CreateGroup}()$ \quad : crear un nuevo grupo
    \item $\text{JoinGroup}(\mathit{GID})$ \quad \quad \ : unirse a un grupo
    \item $\text{LeaveGroup}(\mathit{GID})$ \quad \ : dejar un grupo o por detección de término o fallas
\end{itemize}

% \begin{itemize}
%     \item \textbf{Adicionales.} Además, para gestionar el protocolo:
%     \begin{itemize}
%         \item $\mathit{List} \leftarrow \text{Members}(\mathit{GID})$ \quad : Recibir lista de miembros (vista)
%         \item $\text{SignalChanges}(\mathit{GID})$ \ : señalizar un cambio de vista
%     \end{itemize}
% \end{itemize}
\textcolor{red}{\textbf{Obs.1}} Notar que los 3 protocolos antes descritos tienen entrega atómica.


\subsection{Algoritmo de PAXOS y otros (consenso con fallas de crash)}

Paxos se usa para mantener consistente información del sistema. Como la información de la configuración del sistema. Permite coordinación tolerante a fallos. \textcolor{red}{Paxos trabaja con un modelo de fallas de \textit{crash} (no bizantinas), con omisión de mensajes}. \textcolor{blue}{Trabajamos en una red con comunicación no fiable, y por paso de mensajes}, los mensajes pueden sufrir retardos en la entrega (lo que hace que paxos sea parcialmente sincronico), los mensajes pueden duplicarse, desordenarse o perder, pero no corromperse (modelo de falla de omisión). \textcolor{red}{A nivel de tolerancia a fallas, solo soporta para $2f+1\leq n$}.

\textbf{Roles de agentes}:
\begin{itemize}
    \item \textbf{\textit{Proposer}}: Propone un valor de un cliente para que sea aceptado por consenso.
    \item \textbf{\textit{Acceptor}}: Elige (o rechaza) alguna propuesta de un \textit{Proposer} y les comunica su aceptación. Este componente tiene acceso a memoria estable (esto es debido a que debe recordar su decisión en caso de fallas)
    \item \textbf{\textit{Learner}}: Aprende cuál es el valor elegido por la mayoría de los \textit{Acceptors}.
\end{itemize}

\textcolor{red}{\textbf{Obs.1:}} Un acceptor y un proposer puede estar en un mismo proceso, pero no pueden haber mas de dos acceptor en un mismo proceso.

Paxos cuenta con dos pasos escenciales:

\textcolor{red}{\textbf{Paso 1}}:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\linewidth]{img/Paso_1_paxos.png}
    \caption{Primer paso de Paxos}\label{fig:1761859086537}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Por el lado del \textcolor{red}{\textbf{proposer:}} Se propone una propuesta con un valor $VALUE$, y esta propuesta tiene un ID asociado (este id es estrictamente creciente).

Por el lado del \textcolor{red}{\textbf{acceptor:}} \textcolor{red}{El acceptor verifica si el ID de la propuesta es mayor al que ya tiene} (en caso de que no este no responde), para el caso donde si es el mayor, el ID recibido, sera el nuevo ID máximo, si la propuesta no ha sido aceptada, este le responde a al proposer con un una promesa con el ID, caso contrario, este responde con una promesa con el ID, el ID aceptado, y el $VALUE$ aceptado.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textcolor{red}{\textbf{Paso 2}}:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\linewidth]{img/Paso_2_paxos.png}
    \caption{Segundo paso de Paxos}\label{fig:1761859213280}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\textcolor{red}{\textbf{Fase 2A (Aceptación)}}:

    Por el lado del \textcolor{red}{\textbf{proposer}}: \textcolor{Sepia}{ Si un proposer ha recibido promesas de la mayoría de los acceptors, comprueba si alguna respuesta incluye una propuesta previamente aceptada}; si existe, adopta el VALUE de la propuesta con el ID más alto, en caso contrario mantiene su VALUE original. Finalmente envía a la mayoría de los acceptors un mensaje de aceptación con su ID y el VALUE seleccionado.
    
    Por el lado del \textcolor{red}{\textbf{acceptor:}} En caso de que el acceptor reciba un mensaje de aceptación con un ID mayor o igual al maximo ID conocido, \textcolor{ForestGreen}{este informa a los Learners del valor aceptado}.


\textcolor{red}{\textbf{Fase 2B (Aprendizaje)}}:

Por el lado del \textcolor{red}{\textbf{learner:}} Cuando un learner recibe el mismo par (ID, VALUE) aceptado por una mayoría de acceptors, registra ese VALUE como el valor elegido (consenso) y lo entrega a la aplicación correspondiente.

Por el lado del \textcolor{red}{\textbf{proposer:}} Si un proposer recibe confirmaciones de aceptación (accepted) de una mayoría de acceptors para su propuesta (ID, VALUE), considera que el valor ha sido elegido y puede difundir el resultado a los learners o al cliente.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% \textbf{Proposer:}
% \begin{itemize}
%     \item \textit{ID} : Identificador único y ordenado de una propuesta.
%     \item \textit{cnt} : Mayor \textit{ID} conocido en el sistema (podría ser un TS o contador con UID)
% \end{itemize}


% \textbf{Acceptor:}
% \begin{itemize}
%     \item \textit{max\_id} : Máximo identificador de propuesta conocido por \textit{Acceptor} y que respondió con una promesa (en 1\textsuperscript{a} fase).
%     \item \textit{proposal\_accepted} : El \textit{Acceptor} ha aceptado una propuesta (en 2\textsuperscript{a} fase), una variable booleana.
    
 
%     \item \textit{accepted\_ID} : \textit{ID} de la propuesta aceptada (en 2\textsuperscript{a} fase). \tikz[overlay,remember picture] \node (start-brace) {};
%     \item \textit{accepted\_VALUE} : Valor de la propuesta aceptada (en 2\textsuperscript{a} fase). \tikz[overlay,remember picture] \node (end-brace) {};
% \end{itemize}

\textcolor{ForestGreen}{El quorum para aceptar un valor es de $\lfloor \frac{n}{2} \rfloor + 1$}